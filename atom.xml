<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jelon</title>
  
  <subtitle>个人博客小站</subtitle>
  <link href="https://jangdelong.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://jangdelong.github.io/blog/"/>
  <updated>2023-04-15T00:22:48.000Z</updated>
  <id>https://jangdelong.github.io/blog/</id>
  
  <author>
    <name>Jelon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node.js多线程</title>
    <link href="https://jangdelong.github.io/blog/posts/node-multi-process/"/>
    <id>https://jangdelong.github.io/blog/posts/node-multi-process/</id>
    <published>2023-04-15T00:22:48.000Z</published>
    <updated>2023-04-15T00:22:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Node.js 中，可以使用多种方式实现多线程编程，其中最常用的方式包括：</p><ol><li>使用 Worker Threads 模块：这是 Node.js 内置的一个模块，它提供了创建和管理多线程的 API。通过该模块，可以在 Node.js 中启动多个线程来执行不同的任务，以提高应用程序的性能和响应速度。该模块使用了共享内存和线程间消息传递来实现多线程编程。</li><li>使用 Child Processes 模块：该模块也是 Node.js 内置的一个模块，它允许创建子进程来执行一些独立的任务。这些子进程可以通过 IPC（进程间通信）与主进程进行通信，从而实现多线程编程。</li><li>使用 Cluster 模块：该模块允许将 Node.js 应用程序分为多个进程，每个进程都可以处理来自客户端的请求。通过将请求分配给不同的进程，可以有效地利用多核 CPU，从而提高应用程序的性能。</li></ol><p>需要注意的是，虽然 Node.js 可以使用多线程来提高应用程序的性能，但多线程编程也可能会带来一些问题，如竞争条件和死锁等。因此，在使用多线程编程时，需要仔细考虑和处理这些问题，以确保应用程序的正确性和稳定性。</p><p>详细展开说如下。</p><ol><li>使用 Worker Threads 模块</li></ol><p>Worker Threads 是 Node.js 内置的一个模块，它提供了一种在 Node.js 中创建和管理多线程的方式。通过该模块，可以在 Node.js 中启动多个线程来执行不同的任务，以提高应用程序的性能和响应速度。</p><p>Worker Threads 模块使用了共享内存和线程间消息传递来实现多线程编程。具体来说，可以通过 Worker 类来创建和管理多个线程，每个线程都可以独立地执行一个任务。在任务执行过程中，可以使用 postMessage() 方法向其他线程发送消息，也可以使用 on() 方法监听其他线程发送的消息。</p><p>需要注意的是，由于多个线程共享同一个内存空间，因此需要特别小心，避免出现竞争条件和内存泄漏等问题。</p><p>以下是使用 Worker Threads 模块示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Worker &#125; = <span class="built_in">require</span>(<span class="string">&#x27;worker_threads&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runService</span>(<span class="params">workerData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;./worker.js&#x27;</span>, &#123; workerData &#125;);</span><br><span class="line">    worker.on(<span class="string">&#x27;message&#x27;</span>, resolve);</span><br><span class="line">    worker.on(<span class="string">&#x27;error&#x27;</span>, reject);</span><br><span class="line">    worker.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function">(<span class="params">code</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (code !== <span class="number">0</span>)</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Worker stopped with exit code <span class="subst">$&#123;code&#125;</span>`</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> runService(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们使用 Worker Threads 模块创建了一个新的 Worker 对象，并指定了需要执行的 worker.js 文件和传递给它的 workerData 参数。在 worker.js 文件中，我们可以使用 parentPort.postMessage() 方法向主线程发送消息，也可以使用 workerData 属性获取从主线程传递过来的参数。</p><ol start="2"><li>使用 Child Processes 模块</li></ol><p>Child Processes 模块也是 Node.js 内置的一个模块，它允许创建子进程来执行一些独立的任务。这些子进程可以通过 IPC（进程间通信）与主进程进行通信，从而实现多线程编程。</p><p>使用 Child Processes 模块时，可以通过 spawn() 方法创建一个子进程，并指定该子进程执行的命令和参数。子进程创建后，可以使用 stdin、stdout 和 stderr 等标准 I/O 流与其进行通信。此外，还可以使用 IPC 机制来实现主进程和子进程之间的通信。</p><p>需要注意的是，子进程与主进程之间的通信会涉及到进程间的上下文切换，因此在大规模并发的情况下，可能会导致性能问题。</p><p>以下是使用 Child Processes 模块示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">&#x27;ls&#x27;</span>, [<span class="string">&#x27;-lh&#x27;</span>, <span class="string">&#x27;/usr&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">child.stdout.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`stdout: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.stderr.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">`stderr: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.on(<span class="string">&#x27;close&#x27;</span>, <span class="function">(<span class="params">code</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`child process exited with code <span class="subst">$&#123;code&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们使用 Child Processes 模块创建了一个新的子进程，并指定需要执行的 ls 命令和参数。在子进程中，我们可以使用 process.stdout 和 process.stderr 对象输出日志信息，也可以使用 process.send() 方法向主进程发送消息。</p><ol start="3"><li>使用 Cluster 模块</li></ol><p>Cluster 模块允许将 Node.js 应用程序分为多个进程，每个进程都可以处理来自客户端的请求。通过将请求分配给不同的进程，可以有效地利用多核 CPU，从而提高应用程序的性能。</p><p>在使用 Cluster 模块时，可以通过调用 cluster.fork() 方法来创建一个新的工作进程，并将其注册到主进程的事件循环中。主进程和工作进程之间可以使用 IPC 机制进行通信，并共享一些数据和资源。此外，工作进程也可以独立地处理客户端的请求，从而提高应用程序的性能和可扩展性。</p><p>需要注意的是，Cluster 模块虽然可以提高应用程序的性能，但也会带来一些复杂性和挑战。例如，需要考虑进程间通信的问题、负载均衡的问题以及进程的崩溃等问题。</p><p>以下是使用 Cluster 模块示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">&#x27;cluster&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> numCPUs = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>).cpus().length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Master <span class="subst">$&#123;process.pid&#125;</span> is running`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCPUs; i++) &#123;</span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cluster.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function">(<span class="params">worker, code, signal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`worker <span class="subst">$&#123;worker.process.pid&#125;</span> died`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Worker <span class="subst">$&#123;process.pid&#125;</span> started`</span>);</span><br><span class="line"></span><br><span class="line">  http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>);</span><br><span class="line">    res.end(<span class="string">&#x27;Hello World\n&#x27;</span>);</span><br><span class="line">  &#125;).listen(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Worker <span class="subst">$&#123;process.pid&#125;</span> listening on port 8000`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们使用 Cluster 模块创建了多个工作进程，并使用 HTTP 模块创建了一个 Web 服务器。每个工作进程都可以独立地处理客户端的请求，并使用 console.log() 方法输出日志信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Node.js 中，可以使用多种方式实现多线程编程，其中最常用的方式包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 Worker Threads 模块：这是 Node.js 内置的一个模块，它提供了创建和管理多线程的 API。通过该模块，可以在 Node.js 中启动多个线程来</summary>
      
    
    
    
    <category term="Web技术" scheme="https://jangdelong.github.io/blog/categories/Web%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Node.js" scheme="https://jangdelong.github.io/blog/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Selenium 自动化测试</title>
    <link href="https://jangdelong.github.io/blog/posts/selenium/"/>
    <id>https://jangdelong.github.io/blog/posts/selenium/</id>
    <published>2023-03-18T00:58:38.000Z</published>
    <updated>2023-03-18T00:58:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>Selenium 是一种流行的自动化测试工具，它可以用于测试 Web 应用程序的功能和用户界面。Selenium 提供了一个强大的 API，可以用多种编程语言（如 Java、Python、C# 等）编写自动化测试脚本。</p><p>以下是 Selenium 自动化测试的一般步骤：</p><ol><li>安装 Selenium 和相应的浏览器驱动（如 ChromeDriver、FirefoxDriver 等）。</li><li>编写测试脚本，使用 Selenium API 模拟用户操作（如点击按钮、填写表单等），并对网页元素进行定位和操作（如查找元素、获取元素属性等）。</li><li>运行测试脚本，Selenium 将自动打开浏览器，并在浏览器中执行测试脚本。</li><li>测试结果将被记录在测试报告中，可以用于检查测试用例的执行情况和发现可能存在的问题。</li></ol><p>Selenium 可以通过集成其他测试框架（如 TestNG、JUnit、PyTest 等）来扩展其功能。此外，Selenium 还支持分布式测试和并行测试，可以提高测试效率。</p><p><strong>Selenium 自动化测试实例</strong></p><p>以下是一个简单的 Selenium 自动化测试实例，使用 Python 编写：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 Chrome 浏览器实例</span></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问指定的网页</span></span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在搜索框中输入关键字并提交搜索</span></span><br><span class="line">search_box = driver.find_element_by_name(<span class="string">&quot;wd&quot;</span>)</span><br><span class="line">search_box.send_keys(<span class="string">&quot;Selenium 自动化测试&quot;</span>)</span><br><span class="line">search_box.submit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印搜索结果页面的标题</span></span><br><span class="line">print(driver.title)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭浏览器</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><p>上述代码会打开一个 Chrome 浏览器实例，访问百度首页，然后在搜索框中输入关键字“Selenium 自动化测试”并提交搜索。最后，它会打印搜索结果页面的标题，并关闭浏览器。</p><p>这只是一个简单的示例，实际上可以使用 Selenium 进行更复杂的自动化测试，例如模拟用户登录、填写表单、执行 JavaScript 等。</p><p><strong>Selenium 自动化测试实例js版本</strong></p><p>以下是一个使用 Selenium 进行 JavaScript 自动化测试的示例，使用 JavaScript 编写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webdriver = <span class="built_in">require</span>(<span class="string">&#x27;selenium-webdriver&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 Chrome 浏览器实例</span></span><br><span class="line"><span class="keyword">const</span> driver = <span class="keyword">new</span> webdriver.Builder()</span><br><span class="line">    .forBrowser(<span class="string">&#x27;chrome&#x27;</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问指定的网页</span></span><br><span class="line">driver.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 JavaScript</span></span><br><span class="line">driver.executeScript(<span class="string">&quot;alert(&#x27;Hello, world!&#x27;)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待用户关闭弹窗</span></span><br><span class="line">driver.switchTo().alert().accept();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭浏览器</span></span><br><span class="line">driver.quit();</span><br></pre></td></tr></table></figure><p>上述代码会打开一个 Chrome 浏览器实例，访问百度首页，然后执行一个 JavaScript 弹窗，显示“Hello, world!”。然后，它会等待用户关闭弹窗，最后关闭浏览器。</p><p>这只是一个简单的示例，实际上可以使用 Selenium 进行更复杂的 JavaScript 自动化测试，例如执行特定的 DOM 操作、获取页面元素的属性和值等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Selenium 是一种流行的自动化测试工具，它可以用于测试 Web 应用程序的功能和用户界面。Selenium 提供了一个强大的 API，可以用多种编程语言（如 Java、Python、C# 等）编写自动化测试脚本。&lt;/p&gt;
&lt;p&gt;以下是 Selenium 自动化测试的一</summary>
      
    
    
    
    <category term="Web技术" scheme="https://jangdelong.github.io/blog/categories/Web%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Selenium" scheme="https://jangdelong.github.io/blog/tags/Selenium/"/>
    
    <category term="测试" scheme="https://jangdelong.github.io/blog/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何开发一个vscode插件</title>
    <link href="https://jangdelong.github.io/blog/posts/create-a-vscode-plugin/"/>
    <id>https://jangdelong.github.io/blog/posts/create-a-vscode-plugin/</id>
    <published>2023-03-13T18:32:24.000Z</published>
    <updated>2023-03-13T18:32:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果您想要开发 Visual Studio Code 的插件，以下是一些可以帮助您入门的步骤：</p><ol><li>准备工作</li></ol><p>在开始之前，请确保您安装了 Visual Studio Code。您还需要安装 Node.js 和 npm。npm 是 Node.js 的包管理器，可以用来安装和管理项目中的依赖项。</p><ol start="2"><li>创建一个插件项目</li></ol><p>您可以使用 Yeoman 和 Generator Code 生成器来快速创建一个插件项目。Generator Code 是一个官方的生成器，它会自动生成一个基本的插件项目，并提供一些示例代码和文件。您可以使用以下命令安装 Yeoman 和 Generator Code：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yo generator-code</span><br></pre></td></tr></table></figure><p>然后，您可以使用以下命令来生成插件项目：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yo code</span><br></pre></td></tr></table></figure><p>此命令将引导您完成创建插件项目的过程，并要求您提供一些信息，例如插件名称、描述等。</p><ol start="3"><li>编写插件代码</li></ol><p>在项目中，您可以在 src 文件夹中找到 extension.ts 文件。这是插件的主要文件，您可以在其中编写插件逻辑。这个文件导出了一个名为 activate 的函数，这个函数将在插件被激活时调用。您可以在这个函数中注册命令、添加菜单等。</p><ol start="4"><li>调试插件</li></ol><p>Visual Studio Code 提供了一个内置的调试器，可以帮助您调试插件代码。您可以在 launch.json 文件中配置调试器选项，并使用 F5 键启动调试会话。</p><ol start="5"><li>发布插件</li></ol><p>如果您准备将您的插件发布到 Visual Studio Code 的市场，请先在 Visual Studio Code Marketplace 中注册一个账户。然后，在项目根目录中创建一个名为 vscode-extension.vsix 的文件，这是您的插件包。您可以使用以下命令将插件打包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsce package</span><br></pre></td></tr></table></figure><p>然后，您可以使用以下命令将插件发布到市场：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsce publish</span><br></pre></td></tr></table></figure><p>注意：在发布插件之前，请确保您遵循了 Visual Studio Code 的插件发布指南，确保您的插件符合市场的规定和要求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果您想要开发 Visual Studio Code 的插件，以下是一些可以帮助您入门的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;准备工作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在开始之前，请确保您安装了 Visual Studio Code。您还需要安装 Node.js 和 npm。npm</summary>
      
    
    
    
    <category term="Web技术" scheme="https://jangdelong.github.io/blog/categories/Web%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="vscode" scheme="https://jangdelong.github.io/blog/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>给项目 npm 依赖包升级</title>
    <link href="https://jangdelong.github.io/blog/posts/npm-check-updates/"/>
    <id>https://jangdelong.github.io/blog/posts/npm-check-updates/</id>
    <published>2021-01-12T19:55:33.000Z</published>
    <updated>2021-01-12T19:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>升级之前要先检查更新</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm outdated</span><br></pre></td></tr></table></figure><p>执行以上命令，可以看到所有可以更新的模块。<br>我们需要先更新 package.json 文件。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>我们需要安装 <code>npm-check-updates</code> 模块</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-check-updates</span><br></pre></td></tr></table></figure><p>检查可更新的模块</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncu</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm-check-updates</span><br></pre></td></tr></table></figure><p>以上两条命令都可以检查可更新模块。接下来更新 package.json 的依赖包到最新版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncu -u</span><br></pre></td></tr></table></figure><p>以上命令执行时更新全部模块。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>实际场景不建议一次性全部更新，有一定的风险，可以根据实际需要，更新指定的模块，并且可以根据作用范围在后面加上 -D、-S 或者 -g。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update xxxx <span class="comment"># -D 、-S 或者 -g</span></span><br></pre></td></tr></table></figure><p>如果，是需要指定更新到某个版本可提前修改 package.json 中的版本号。</p><p>保险起见，更新完之后，可先删除 node_modules 目录，然后重新安装 npm 包。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;升级之前要先检查更新&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;</summary>
      
    
    
    
    <category term="Web技术" scheme="https://jangdelong.github.io/blog/categories/Web%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="npm" scheme="https://jangdelong.github.io/blog/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】93. 复原IP地址</title>
    <link href="https://jangdelong.github.io/blog/posts/leetcode-93/"/>
    <id>https://jangdelong.github.io/blog/posts/leetcode-93/</id>
    <published>2020-08-13T00:00:00.000Z</published>
    <updated>2020-08-13T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 ‘.’ 分隔。</p><p><strong>示例:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;25525511135&quot;</span></span><br><span class="line">输出: [<span class="string">&quot;255.255.11.135&quot;</span>, <span class="string">&quot;255.255.111.35&quot;</span>]</span><br></pre></td></tr></table></figure><h5 id="参考解答"><a href="#参考解答" class="headerlink" title="参考解答"></a>参考解答</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> restoreIpAddresses = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * cur 当前</span></span><br><span class="line"><span class="comment">   * sub 剩余字符串</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> search = <span class="function">(<span class="params">cur, sub</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 超出范围</span></span><br><span class="line">    <span class="keyword">if</span> (sub.length &gt; <span class="number">12</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.length === <span class="number">4</span> &amp;&amp; cur.join(<span class="string">&#x27;&#x27;</span>) === s) &#123;</span><br><span class="line">      res.push(cur.join(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ip位最长只有三位</span></span><br><span class="line">      <span class="keyword">const</span> len = <span class="built_in">Math</span>.min(<span class="number">3</span>, sub.length)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> tmp = sub.substr(<span class="number">0</span>, i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; <span class="number">256</span> &amp;&amp; <span class="built_in">Number</span>(tmp).toString() === tmp) &#123;</span><br><span class="line">          search([ ...cur, tmp ], sub.substr(i + <span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  search([], s)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h5><blockquote><p>递归</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。&lt;/p&gt;
&lt;p&gt;有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 ‘.’ 分隔。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure cla</summary>
      
    
    
    
    <category term="算法练习" scheme="https://jangdelong.github.io/blog/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://jangdelong.github.io/blog/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://jangdelong.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】209. 长度最小的子数组</title>
    <link href="https://jangdelong.github.io/blog/posts/leetcode-209/"/>
    <id>https://jangdelong.github.io/blog/posts/leetcode-209/</id>
    <published>2020-08-10T00:00:00.000Z</published>
    <updated>2020-08-10T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p> </p><p><strong>示例：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = 7, nums = <span class="comment">[2,3,1,2,4,3]</span></span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 <span class="comment">[4,3]</span> 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><p> </p><p><strong>进阶：</strong></p><ul><li>如果你已经完成了 O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。</li></ul><h5 id="参考解答"><a href="#参考解答" class="headerlink" title="参考解答"></a>参考解答</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="function"><span class="keyword">function</span>(<span class="params">s, nums</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 双指针</span></span><br><span class="line">  <span class="keyword">let</span> minLen = nums.length + <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (j &lt; nums.length) &#123; <span class="comment">// 放大</span></span><br><span class="line">    sum += nums[j]</span><br><span class="line">    <span class="keyword">while</span> (sum &gt;= s) &#123; <span class="comment">// 缩小</span></span><br><span class="line">      sum -= nums[i]</span><br><span class="line">      minLen = <span class="built_in">Math</span>.min(minLen, j - i + <span class="number">1</span>)</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">    j++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> minLen === nums.length + <span class="number">1</span> ? <span class="number">0</span> : minLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="参考思路"><a href="#参考思路" class="headerlink" title="参考思路"></a>参考思路</h5><ul><li>扩张窗口：为了找到一个可行解，找到了就不再扩张</li><li>收缩窗口：在长度上优化该可行解，直到条件被破坏</li><li>寻找下一个可行解，然后再优化。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=</summary>
      
    
    
    
    <category term="算法练习" scheme="https://jangdelong.github.io/blog/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://jangdelong.github.io/blog/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://jangdelong.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】56. 合并区间</title>
    <link href="https://jangdelong.github.io/blog/posts/leetcode-56/"/>
    <id>https://jangdelong.github.io/blog/posts/leetcode-56/</id>
    <published>2020-08-09T00:00:00.000Z</published>
    <updated>2020-08-09T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个区间的集合，请合并所有重叠的区间。</p><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">解释: 区间 [<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">6</span>] 重叠, 将它们合并为 [<span class="number">1</span>,<span class="number">6</span>].</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">[[1,4],[4,5]]</span></span><br><span class="line">输出: <span class="string">[[1,5]]</span></span><br><span class="line">解释: 区间 [<span class="number">1</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">5</span>] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><h5 id="个人解答"><a href="#个人解答" class="headerlink" title="个人解答"></a>个人解答</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">intervals</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先根据左顶点进行升序排序</span></span><br><span class="line">  intervals = intervals.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">0</span>] - b[<span class="number">0</span>])</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; intervals.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> a2 = intervals[i][<span class="number">1</span>] <span class="comment">// 当前元素的右顶点</span></span><br><span class="line">    <span class="keyword">const</span> b1 = intervals[i+<span class="number">1</span>][<span class="number">0</span>] <span class="comment">// 下个元素的左顶点</span></span><br><span class="line">    <span class="keyword">const</span> b2 = intervals[i+<span class="number">1</span>][<span class="number">1</span>] <span class="comment">// 下个元素的右顶点</span></span><br><span class="line">    <span class="keyword">if</span> (a2 &gt;= b1) &#123; <span class="comment">// 当前元素的右顶点与下个元素左顶点比较</span></span><br><span class="line">      intervals[i][<span class="number">1</span>] = <span class="built_in">Math</span>.max(a2, b2)</span><br><span class="line">      intervals.splice(i + <span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 删掉下标 i + 1</span></span><br><span class="line">      i--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> intervals</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><ol><li>先按左顶点进行升序排序；</li><li>循环判断 intervals[i][1] &gt;= intervals[i+1][0]，即当前元素右顶点与下个元素左顶点比较；</li><li>当前元素右顶点取值，符合条件删除下一个元素 intervals[i+1]。</li></ol><blockquote><p>注：</p><p>边界i&lt;intervals.length-1</p><p>因为删除元素，数组变短了。此时： i–</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给出一个区间的集合，请合并所有重叠的区间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight prolog&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="算法练习" scheme="https://jangdelong.github.io/blog/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://jangdelong.github.io/blog/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://jangdelong.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】102. 二叉树的层序遍历</title>
    <link href="https://jangdelong.github.io/blog/posts/leetcode-102/"/>
    <id>https://jangdelong.github.io/blog/posts/leetcode-102/</id>
    <published>2020-07-24T00:00:00.000Z</published>
    <updated>2020-07-24T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例：</strong><br>二叉树：[3,9,20,null,null,15,7],</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / <span class="string">\</span></span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  <span class="string">\</span></span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="个人解答"><a href="#个人解答" class="headerlink" title="个人解答"></a>个人解答</h5><p>广度遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> []</span><br><span class="line">  <span class="keyword">var</span> res = []</span><br><span class="line">  <span class="keyword">var</span> queue = [ root ]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123; <span class="comment">// 纵向遍历</span></span><br><span class="line">    <span class="keyword">var</span> curr = [] <span class="comment">// 当前行</span></span><br><span class="line">    <span class="keyword">var</span> next = [] <span class="comment">// 下一行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123; <span class="comment">// 横向遍历</span></span><br><span class="line">      <span class="keyword">var</span> node = queue.shift()</span><br><span class="line">      curr.push(node.val)</span><br><span class="line">      <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">        next.push(node.left)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.right) &#123;</span><br><span class="line">        next.push(node.right)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(curr)</span><br><span class="line">    queue = next</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>深度遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> levelTransal = <span class="function"><span class="keyword">function</span> (<span class="params">node, order</span>) </span>&#123;</span><br><span class="line">    res[order] = res[order] || []</span><br><span class="line">    res[order].push(node.val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">      levelTransal(node.left, order + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right) &#123;</span><br><span class="line">      levelTransal(node.right, order + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> [] </span><br><span class="line">  levelTransal(root, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><ol><li>广度遍历（双重循环）；</li><li>深度遍历（递归）。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;br&gt;二叉树：[3,9,20,null,null,15,7],&lt;/p&gt;
&lt;figure class=&quot;highlight l</summary>
      
    
    
    
    <category term="算法练习" scheme="https://jangdelong.github.io/blog/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://jangdelong.github.io/blog/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://jangdelong.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】61. 旋转链表</title>
    <link href="https://jangdelong.github.io/blog/posts/leetcode-61/"/>
    <id>https://jangdelong.github.io/blog/posts/leetcode-61/</id>
    <published>2020-07-23T00:00:00.000Z</published>
    <updated>2020-07-23T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p><p><strong>示例 1:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL, k = <span class="number">2</span></span><br><span class="line">输出: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: <span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br><span class="line">向右旋转 <span class="number">2</span> 步: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;NULL, k = <span class="number">4</span></span><br><span class="line">输出: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line">向右旋转 <span class="number">2</span> 步: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">0</span>-&gt;NULL</span><br><span class="line">向右旋转 <span class="number">3</span> 步: <span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;NULL</span><br><span class="line">向右旋转 <span class="number">4</span> 步: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure><h5 id="个人解答"><a href="#个人解答" class="headerlink" title="个人解答"></a>个人解答</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rotateRight = <span class="function"><span class="keyword">function</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next) <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先闭合环</span></span><br><span class="line">  <span class="keyword">var</span> old_tail = head</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (old_tail.next) &#123;</span><br><span class="line">    old_tail = old_tail.next</span><br><span class="line">    n++</span><br><span class="line">  &#125;</span><br><span class="line">  old_tail.next = head</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断开</span></span><br><span class="line">  <span class="keyword">var</span> new_tail = head</span><br><span class="line">  <span class="keyword">var</span> new_head = head</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n - k % n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    new_tail = new_tail.next</span><br><span class="line">  &#125;</span><br><span class="line">  new_head = new_tail.next <span class="comment">// 重新计算新的头结点</span></span><br><span class="line">  new_tail.next = <span class="literal">null</span> <span class="comment">// 断开</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> new_head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><ol><li>先将链表进行闭环</li><li>从 n - k % n （因为考虑到k &gt; n情况）处断开。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight clean&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;</summary>
      
    
    
    
    <category term="算法练习" scheme="https://jangdelong.github.io/blog/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://jangdelong.github.io/blog/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://jangdelong.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】11. 盛最多水的容器</title>
    <link href="https://jangdelong.github.io/blog/posts/leetcode-11/"/>
    <id>https://jangdelong.github.io/blog/posts/leetcode-11/</id>
    <published>2020-07-21T00:00:00.000Z</published>
    <updated>2020-07-21T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong>你不能倾斜容器，且 n 的值至少为 2。</p><p><img src="https://jangdelong.github.io/blog_img/images/leetcode-11/question_11.jpg" alt="https://jangdelong.github.io/blog_img/images/leetcode-11/question_11.png"></p><p><sup>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</sup></p><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">49</span></span><br></pre></td></tr></table></figure><h5 id="个人解答"><a href="#个人解答" class="headerlink" title="个人解答"></a>个人解答</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">height</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 双指针</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">var</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> j = height.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> cur = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">var</span> h = <span class="built_in">Math</span>.min(height[i], height[j]);</span><br><span class="line">    cur = (j - i) * h;</span><br><span class="line">    res = <span class="built_in">Math</span>.max(res, cur);</span><br><span class="line">    <span class="keyword">if</span> (height[i] &lt; height[j]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>双指针。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;&lt;stron</summary>
      
    
    
    
    <category term="算法练习" scheme="https://jangdelong.github.io/blog/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://jangdelong.github.io/blog/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://jangdelong.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>前端散记 3</title>
    <link href="https://jangdelong.github.io/blog/posts/front-end-notes-3/"/>
    <id>https://jangdelong.github.io/blog/posts/front-end-notes-3/</id>
    <published>2020-06-17T00:00:00.000Z</published>
    <updated>2020-06-17T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在写这篇前端散记之前有写过另外两篇散记，可点击 <a href="https://jelon.info/posts/front-end-notes/">前端散记</a> 和 <a href="https://jelon.info/posts/front-end-notes-2/">前端散记 2</a> 访问。所谓散记，东西都比较零散，更谈不上什么深入，但是至少可以让读者知道一些概念理论，如果深入可以自行去查询相关知识。</p></blockquote><h1 id="async-await-实现原理"><a href="#async-await-实现原理" class="headerlink" title="async await 实现原理"></a>async await 实现原理</h1><p><strong>async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的 async 函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。</p><p>下面给出 spawn 函数的实现，基本就是前文自动执行器的翻版。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">genF</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gen = genF();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">nextF</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> next = nextF();</span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e); </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(next.done) &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(next.value);</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="built_in">Promise</span>.resolve(next.value).then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(v); &#125;);      </span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.throw(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(<span class="literal">undefined</span>); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>async 函数是非常新的语法功能，新到都不属于 ES6，而是属于 ES7。目前，它仍处于提案阶段，但是转码器 Babel 和 regenerator 都已经支持，转码后就能使用。</p><h1 id="async-await-注意点"><a href="#async-await-注意点" class="headerlink" title="async await 注意点"></a>async await 注意点</h1><p>await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sync <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> somethingThatReturnsAPromise();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> somethingThatReturnsAPromise().catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  docs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码会报错，因为 await 用在普通函数之中了。但是，如果将 forEach 方法的参数改成 async 函数，也有问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可能得到错误结果</span></span><br><span class="line">  docs.forEach(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可能不会正常工作，原因是这时三个 db.post 操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用 for 循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果确实希望多个请求并发执行，可以使用 Promise.all 方法。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.map(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用下面的写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.map(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    results.push(<span class="keyword">await</span> promise);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ES5-实现继承"><a href="#ES5-实现继承" class="headerlink" title="ES5 实现继承"></a>ES5 实现继承</h1><p><strong>第一种方式是借助call实现继承：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;parent1&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  Parent1.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&#x27;child1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child1);</span><br></pre></td></tr></table></figure><p>复制代码这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类原型对象中一旦存在方法那么子类无法继承。那么引出下面的方法。</p><p><strong>第二种方式借助原型链实现继承：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;parent2&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&#x27;child2&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child2.prototype = <span class="keyword">new</span> Parent2();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child2());</span><br></pre></td></tr></table></figure><p>看似没有问题，父类的方法和属性都能够访问，但实际上有一个潜在的不足。举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Child2();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Child2();</span><br><span class="line">s1.play.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1.play, s2.play);</span><br></pre></td></tr></table></figure><p>可以看到控制台：</p><p><img src="https://jangdelong.github.io/blog_img/images/front-end-notes-3/1.jpg"></p><p>明明我只改变了s1的play属性，为什么s2也跟着变了呢？很简单，因为两个实例使用的是同一个原型对象。</p><p>那么还有更好的方式么？</p><p><strong>第三种方式：将前两种组合：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent3</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;parent3&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent3.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&#x27;child3&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child3.prototype = <span class="keyword">new</span> Parent3();</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="keyword">new</span> Child3();</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="keyword">new</span> Child3();</span><br><span class="line">s3.play.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s3.play, s4.play);</span><br></pre></td></tr></table></figure><p>可以看到控制台：</p><p><img src="https://jangdelong.github.io/blog_img/images/front-end-notes-3/2.png"></p><p>之前的问题都得以解决。但是这里又徒增了一个新问题，那就是Parent3的构造函数会多执行了一次（Child3.prototype = new Parent3();）。这是我们不愿看到的。那么如何解决这个问题？</p><p><strong>第四种方式: 组合继承的优化1</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent4</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;parent4&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent4.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&#x27;child4&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child4.prototype = Parent4.prototype;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里让将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问，但是我们来测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s3 = <span class="keyword">new</span> Child4();</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="keyword">new</span> Child4();</span><br><span class="line"><span class="built_in">console</span>.log(s3)</span><br></pre></td></tr></table></figure><p><img src="https://jangdelong.github.io/blog_img/images/front-end-notes-3/3.png"></p><p>子类实例的构造函数是Parent4，显然这是不对的，应该是Child4。</p><p><strong>第五种方式(最推荐使用)：优化2</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent5</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;parent5&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent5.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&#x27;child5&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child5.prototype = <span class="built_in">Object</span>.create(Parent5.prototype);</span><br><span class="line">Child5.prototype.constructor = Child5;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是最推荐的一种方式，接近完美的继承。</p><p>因此，小小的继承虽然ES6当中简化了很多，但毋庸置疑的是，js是一门基于原型的语言，所以，用ES5来完成继承非常考验面试者对JS语言本身的理解，尤其是对于原型链是否理解清楚。</p><h1 id="虚拟DOM和Diff算法"><a href="#虚拟DOM和Diff算法" class="headerlink" title="虚拟DOM和Diff算法"></a>虚拟DOM和Diff算法</h1><p><strong>虚拟DOM</strong></p><p>虚拟Dom(virtual dom)到底是什么，简单来讲，就是将真实的dom节点用JavaScript来模拟出来，而Dom变化的对比，放到 Js 层来做。</p><ul><li>传统DOM节点</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>jelon1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>jelon2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>对应虚拟DOM</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  tag: <span class="string">&#x27;ul&#x27;</span>,</span><br><span class="line">  attrs: &#123;</span><br><span class="line">    id: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  children: [</span><br><span class="line">  &#123;</span><br><span class="line">    tag: <span class="string">&#x27;li&#x27;</span>,</span><br><span class="line">    attrs: &#123;</span><br><span class="line">      className: <span class="string">&#x27;item&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    children: [ <span class="string">&#x27;jelon1&#x27;</span> ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    tag: <span class="string">&#x27;li&#x27;</span>,</span><br><span class="line">    attrs: &#123;</span><br><span class="line">      className: <span class="string">&#x27;item&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    children: [ <span class="string">&#x27;jelon2&#x27;</span> ]</span><br><span class="line">  &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>render方法</li></ul><p><strong>diff算法</strong></p><p>关键词：patch</p><p>可参考<a href="https://juejin.im/post/5affd01551882542c83301da#comment">详解vue的diff算法</a></p><p><img src="https://jangdelong.github.io/blog_img/images/front-end-notes-3/4.png?v=1"></p><h1 id="工作中项目优化实践"><a href="#工作中项目优化实践" class="headerlink" title="工作中项目优化实践"></a>工作中项目优化实践</h1><blockquote><p>前端优化主要基于两个目的：</p><ol><li>提升加载速度；</li><li>用户操作起来流畅。<br>因此，以下优化主要是围绕这两个目的展开。</li></ol></blockquote><ol><li>css sprite（雪碧图），iconfont；</li><li>资源懒加载、异步路由；</li><li>前端缓存 LocalStorage 及混合应用 Storage；</li><li>使用 CDN（JS、CSS等资源使用外部域名）；</li><li>Tree Shaking （Webpack 4.0+）；</li><li>预请求；</li><li>资源按需加载；</li><li>gzip （服务器）；</li><li>减少 DOM 操作；</li><li>防抖节流；</li><li>尽量少用iframe；</li><li>尽量规避 CSS 计算。</li></ol><p><strong>参考思路</strong></p><p><img src="https://jangdelong.github.io/blog_img/images/front-end-notes-3/5.jpeg?v=1"></p><p><strong>雅虎军规</strong></p><p><a href="https://developer.yahoo.com/performance/rules.html?guccounter=1">Best Practices for Speeding Up Your Web Site</a></p><h1 id="defineProperty-vs-proxy"><a href="#defineProperty-vs-proxy" class="headerlink" title="defineProperty vs proxy"></a>defineProperty vs proxy</h1><ul><li>Proxy可以直接监听对象而非属性；</li><li>Proxy直接可以劫持整个对象,并返回一个新对象,不管是操作便利程度还是底层功能上都远强于Object.defineProperty；</li><li>Proxy可以直接监听数组的变化；</li><li>Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的。</li></ul><h1 id="手写-call"><a href="#手写-call" class="headerlink" title="手写 call"></a>手写 call</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">&#x27;arguments[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">&#x27;context.fn(&#x27;</span> + args +<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="手写-apply"><a href="#手写-apply" class="headerlink" title="手写 apply"></a>手写 apply</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">Object</span>(context) || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> args = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(<span class="string">&#x27;arr[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">eval</span>(<span class="string">&#x27;context.fn(&#x27;</span> + args + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="手写bind"><a href="#手写bind" class="headerlink" title="手写bind"></a>手写bind</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">asThis, ...args1</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> fn = <span class="built_in">this</span>;  <span class="comment">// 函数调用时，原this其实就是这个调用函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;  <span class="comment">// 同时，返回的新函数也可以接受参数</span></span><br><span class="line">        <span class="keyword">return</span> fn.call(asThis, ...args1, ...args2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="preload和prefetch"><a href="#preload和prefetch" class="headerlink" title="preload和prefetch"></a>preload和prefetch</h1><p>preload特点</p><p>preload加载的资源是在浏览器渲染机制之前进行处理的，并且不会阻塞onload事件；<br>preload可以支持加载多种类型的资源，并且可以加载跨域资源；<br>preload加载的js脚本其加载和执行的过程是分离的。即preload会预加载相应的脚本代码，待到需要时自行调用；<br>prefetch</p><p>prefetch是一种利用浏览器的空闲时间加载页面将来可能用到的资源的一种机制；通常可以用于加载非首页的其他页面所需要的资源，以便加快后续页面的首屏速度；</p><p>prefetch特点</p><p>prefetch加载的资源可以获取非当前页面所需要的资源，并且将其放入缓存至少5分钟（无论资源是否可以缓存）；并且，当页面跳转时，未完成的prefetch请求不会被中断。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>Chrome有四种缓存：http cache、memory cache、Service Worker cache和Push<br>cache。在preload或prefetch的资源加载时，两者均存储在http<br>cache。当资源加载完成后，如果资源是可以被缓存的，那么其被存储在http<br>cache中等待后续使用；如果资源不可被缓存，那么其在被使用前均存储在memory cache；<br>preload和prefetch都没有同域名的限制；<br>preload主要用于预加载当前页面需要的资源；而prefetch主要用于加载将来页面可能需要的资源；<br>不论资源是否可以缓存，prefecth会存储在net-stack cache中至少5分钟；<br>preload需要使用as属性指定特定的资源类型以便浏览器为其分配一定的优先级，并能够正确加载资源；</p><h1 id="如何比较两个-DOM-树的差异？"><a href="#如何比较两个-DOM-树的差异？" class="headerlink" title="如何比较两个 DOM 树的差异？"></a>如何比较两个 DOM 树的差异？</h1><p>两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。</p><p>算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。</p><p>在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在写这篇前端散记之前有写过另外两篇散记，可点击 &lt;a href=&quot;https://jelon.info/posts/front-end-notes/&quot;&gt;前端散记&lt;/a&gt; 和 &lt;a href=&quot;https://jelon.info/posts/fro</summary>
      
    
    
    
    <category term="Web技术" scheme="https://jangdelong.github.io/blog/categories/Web%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="前端" scheme="https://jangdelong.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】94. 二叉树的中序遍历</title>
    <link href="https://jangdelong.github.io/blog/posts/leetcode-94/"/>
    <id>https://jangdelong.github.io/blog/posts/leetcode-94/</id>
    <published>2020-05-27T00:00:00.000Z</published>
    <updated>2020-05-27T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，返回它的中序 遍历。</p><p><strong>示例:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="comment">[1,null,2,3]</span></span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: <span class="comment">[1,3,2]</span></span><br></pre></td></tr></table></figure><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p><h5 id="个人解答"><a href="#个人解答" class="headerlink" title="个人解答"></a>个人解答</h5><p><strong>方法一：递归</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  traversal(root, res)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traversal</span> (<span class="params">root, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left) &#123;</span><br><span class="line">      traversal(root.left, res)</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(root.val)</span><br><span class="line">    <span class="keyword">if</span> (root.right) &#123;</span><br><span class="line">      traversal(root.right, res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法而：栈</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = []</span><br><span class="line">  <span class="keyword">var</span> stack = []</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (root || stack.length) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root.left) &#123; <span class="comment">// 如果有左节点先遍历左节点</span></span><br><span class="line">    stack.push(root)</span><br><span class="line">    root = root.left</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!root.left &amp;&amp; !root.right) &#123; <span class="comment">// 既没有左节点也没有右节点</span></span><br><span class="line">    res.push(root.val)</span><br><span class="line">    root = stack.pop() <span class="comment">// 回溯</span></span><br><span class="line">    root &amp;&amp; (root.left = <span class="literal">null</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right) &#123; <span class="comment">// 如果有右节点</span></span><br><span class="line">    res.push(root.val)</span><br><span class="line">    root = root.right</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p><img src="https://jangdelong.github.io/blog_img/images/leetcode-94/1.png" alt="https://jangdelong.github.io/blog_img/images/leetcode-94/1.png"></p><ul><li><p>前序遍历：先输出根节点，在依次前序遍历左子树和右子树；</p></li><li><p><strong>中序遍历：先中序遍历左子树，在输出根节点，最后中序遍历右子树；</strong></p></li><li><p>后序遍历：先后序遍历左子树，接着后序遍历右子树，最后输出根节点。</p></li></ul><p>输出</p><p>前序遍历：1，2，4，5，3，6，7；</p><p><strong>中序遍历：4，2，5，1，3，7，6</strong></p><p>后序遍历：4，5，2，7，6，3，1</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个二叉树，返回它的中序 遍历。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight inform7&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    <category term="算法练习" scheme="https://jangdelong.github.io/blog/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://jangdelong.github.io/blog/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://jangdelong.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】面试题 02.05. 链表求和</title>
    <link href="https://jangdelong.github.io/blog/posts/leetcode-02-05/"/>
    <id>https://jangdelong.github.io/blog/posts/leetcode-02-05/</id>
    <published>2020-05-21T00:00:00.000Z</published>
    <updated>2020-05-21T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个用链表表示的整数，每个节点包含一个数位。</p><p>这些数位是反向存放的，也就是个位排在链表首部。</p><p>编写函数对这两个整数求和，并用链表形式返回结果。</p><p> </p><p><strong>示例：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(<span class="number">7</span> -&gt; <span class="number">1</span> -&gt; <span class="number">6</span>) + (<span class="number">5</span> -&gt; <span class="number">9</span> -&gt; <span class="number">2</span>)，即<span class="number">617</span> + <span class="number">295</span></span><br><span class="line">输出：<span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">9</span>，即<span class="number">912</span></span><br><span class="line">进阶：假设这些数位是正向存放的，请再做一遍。</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：(<span class="number">6</span> -&gt; <span class="number">1</span> -&gt; <span class="number">7</span>) + (<span class="number">2</span> -&gt; <span class="number">9</span> -&gt; <span class="number">5</span>)，即<span class="number">617</span> + <span class="number">295</span></span><br><span class="line">输出：<span class="number">9</span> -&gt; <span class="number">1</span> -&gt; <span class="number">2</span>，即<span class="number">912</span></span><br></pre></td></tr></table></figure><h5 id="个人解答"><a href="#个人解答" class="headerlink" title="个人解答"></a>个人解答</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span> <span class="comment">// 进数位</span></span><br><span class="line">  <span class="keyword">var</span> head = &#123;&#125; <span class="comment">// 头节点</span></span><br><span class="line">  <span class="keyword">var</span> cur = head <span class="comment">// 指针节点</span></span><br><span class="line">  <span class="keyword">while</span> (l1 || l2 || count) &#123;</span><br><span class="line">    count += (l1 &amp;&amp; l1.val) + (l2 &amp;&amp; l2.val)</span><br><span class="line">    cur = cur.next = <span class="keyword">new</span> ListNode(count % <span class="number">10</span>)</span><br><span class="line">    l1 = l1 &amp;&amp; l1.next</span><br><span class="line">    l2 = l2 &amp;&amp; l2.next</span><br><span class="line">    count = <span class="built_in">Math</span>.floor(count / <span class="number">10</span>)  <span class="comment">/* 进1 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> head.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="参考思路"><a href="#参考思路" class="headerlink" title="参考思路"></a>参考思路</h5><p>双指针。</p><p>时间复杂度：o(n)<br>空间复杂度：o(n)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定两个用链表表示的整数，每个节点包含一个数位。&lt;/p&gt;
&lt;p&gt;这些数位是反向存放的，也就是个位排在链表首部。&lt;/p&gt;
&lt;p&gt;编写函数对这两个整数求和，并用链表形式返回结果。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;figure </summary>
      
    
    
    
    <category term="算法练习" scheme="https://jangdelong.github.io/blog/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://jangdelong.github.io/blog/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://jangdelong.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】面试题22. 链表中倒数第k个节点</title>
    <link href="https://jangdelong.github.io/blog/posts/leetcode-case-22/"/>
    <id>https://jangdelong.github.io/blog/posts/leetcode-case-22/</id>
    <published>2020-05-21T00:00:00.000Z</published>
    <updated>2020-05-21T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p> </p><p><strong>示例：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 和 k = <span class="number">2.</span></span><br><span class="line"></span><br><span class="line">返回链表 <span class="number">4</span>-&gt;<span class="number">5.</span></span><br></pre></td></tr></table></figure><h5 id="个人解答"><a href="#个人解答" class="headerlink" title="个人解答"></a>个人解答</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="keyword">var</span> getKthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (k &lt; <span class="number">0</span> || !head) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> pointer = head</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pointer.next) &#123;</span><br><span class="line">      pointer = pointer.next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (pointer.next) &#123;</span><br><span class="line">    head = head.next</span><br><span class="line">    pointer = pointer.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>双指针</p><ol><li>参考指针 pointer 先从头遍历到 k，然后剩下长度为 len - k；</li><li>head 指针再从投开始遍历 len - k 个节点，即可得到倒数第 k 个节点。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;st</summary>
      
    
    
    
    <category term="算法练习" scheme="https://jangdelong.github.io/blog/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://jangdelong.github.io/blog/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://jangdelong.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】206. 反转链表</title>
    <link href="https://jangdelong.github.io/blog/posts/leetcode-206/"/>
    <id>https://jangdelong.github.io/blog/posts/leetcode-206/</id>
    <published>2020-05-20T00:00:00.000Z</published>
    <updated>2020-05-20T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>反转一个单链表。</p><p><strong>示例:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong></p><p>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><h5 id="个人解答"><a href="#个人解答" class="headerlink" title="个人解答"></a>个人解答</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prev = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> cur = head</span><br><span class="line">  <span class="keyword">var</span> tmp = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">    tmp = cur.next</span><br><span class="line">    cur.next = prev</span><br><span class="line">    prev = cur</span><br><span class="line">    cur = tmp</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> prev</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="参考思路"><a href="#参考思路" class="headerlink" title="参考思路"></a>参考思路</h5><p>双指针</p><p><img src="https://jangdelong.github.io/blog_img/images/leetcode-206/1.gif" alt="双指针解法"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;反转一个单链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight clean&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;b</summary>
      
    
    
    
    <category term="算法练习" scheme="https://jangdelong.github.io/blog/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://jangdelong.github.io/blog/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://jangdelong.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】面试题 16.01. 交换数字</title>
    <link href="https://jangdelong.github.io/blog/posts/leetcode-case-16-01/"/>
    <id>https://jangdelong.github.io/blog/posts/leetcode-case-16-01/</id>
    <published>2020-05-18T00:00:00.000Z</published>
    <updated>2020-05-18T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个函数，不用临时变量，直接交换 <code>numbers = [a, b]</code> 中 <code>a</code> 与 <code>b</code> 的值。</p><p><strong>示例：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers = <span class="comment">[1,2]</span></span><br><span class="line">输出: <span class="comment">[2,1]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>numbers.length == 2</li></ul><h5 id="个人解答"><a href="#个人解答" class="headerlink" title="个人解答"></a>个人解答</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">numbers</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 做减法</span></span><br><span class="line"><span class="keyword">var</span> swapNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">  numbers[<span class="number">1</span>] = numbers[<span class="number">0</span>] - numbers[<span class="number">1</span>];</span><br><span class="line">  numbers[<span class="number">0</span>] = numbers[<span class="number">0</span>] - numbers[<span class="number">1</span>];</span><br><span class="line">  numbers[<span class="number">1</span>] = numbers[<span class="number">0</span>] + numbers[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> numbers</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>使用减法思路。</p><p>以 a、b 为例：a = 1; b = 2</p><p>第一遍：b（临时） = a - b;<br>第二遍：a = a - b（临时）; // 得出 a = 原b;<br>第三遍：b = a（原b） + b（临时：原a - 原b）; // 得出 b = 原a;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;编写一个函数，不用临时变量，直接交换 &lt;code&gt;numbers = [a, b]&lt;/code&gt; 中 &lt;code&gt;a&lt;/code&gt; 与 &lt;code&gt;b&lt;/code&gt; 的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;hig</summary>
      
    
    
    
    <category term="算法练习" scheme="https://jangdelong.github.io/blog/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://jangdelong.github.io/blog/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://jangdelong.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>前端散记 2</title>
    <link href="https://jangdelong.github.io/blog/posts/front-end-notes-2/"/>
    <id>https://jangdelong.github.io/blog/posts/front-end-notes-2/</id>
    <published>2020-05-08T00:00:00.000Z</published>
    <updated>2020-05-08T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在写这篇前端散记之前有写过另外一篇散记，可点击 <a href="https://jelon.info/posts/front-end-notes/">前端散记</a> 访问。所谓散记，东西都比较零散，更谈不上什么深入，但是至少可以让读者知道一些概念理论，如果深入可以自行去查询相关知识。</p></blockquote><h1 id="keep-alive-vs-http2"><a href="#keep-alive-vs-http2" class="headerlink" title="keep-alive vs http2"></a>keep-alive vs http2</h1><blockquote><p>有很多文章都说 http2 相比 http1.1 增加了连接复用。这句话其实是不准确的。</p></blockquote><p><strong>在 HTTP 1.1 中 所有的连接默认都是持续连接，除非特殊声明不支持。</strong> 而在 http1.0 中，官方没有支持 keep-alive, 通常会手动在请求头中添加 Connection: Keep-Alive。</p><p>keep-alive 就是 TCP 连接复用的开端。改善的效果就是不再重新建立TCP连接，省去 三次握手 的时间。如下图：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/HTTP_persistent_connection.svg/langzh-450px-HTTP_persistent_connection.svg.png" alt="keep-alive"></p><p>优势有：</p><ul><li>较少的CPU和内存的使用（由于同时打开的连接的减少了）；</li><li>允许请求和应答的HTTP管线化；</li><li>降低拥塞控制 （TCP连接减少了）；</li><li>减少了后续请求的延迟（无需再进行握手）；</li><li>报告错误无需关闭TCP连接。</li></ul><h2 id="http-pipelining"><a href="#http-pipelining" class="headerlink" title="http pipelining"></a>http pipelining</h2><p>有些文章中会有一个误区，就是TCP连接必须等一个请求响应完成后，才能复用。这是不对的，但其实可以注意上面优势里提到到 http pipelining，如下图：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fb/HTTP_pipelining.svg/450px-HTTP_pipelining.svg.png"></p><p>HTTP1.1 中，一个TCP连接里是可以同时发送（实际有先后，但可以在响应前）多个请求的。但它是有序的，遵循先进先出，服务端只能按顺序响应请求（如果前面的请求没有响应完成或需要很长时间，后面的请求就会被阻塞），所以可能发生 队头阻塞（HOL blocking），造成延迟。</p><p>连续的 GET 和 HEAD 请求总可以管线化的。一个连续的幂等请求，如 GET，HEAD，PUT，DELETE，是否可以被管线化取决于一连串请求是否依赖于其他的。</p><p>所以keep-alive 的劣势也很明显：</p><ul><li>Keep-Alive可能会极大的影响服务器性能，因为它在文件被请求之后还保持了不必要的连接很长时间；</li><li>可能发生队头阻塞（HOL blocking），造成延迟。</li></ul><h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><p>HTTP2 主要解决的问题也是 TCP连接复用。但它比 keep-alive 更彻底，类似于通信工程里的时分复用，多个请求可以同时发送（不分先后），同时响应，解决了 队头阻塞（HOL blocking）的问题，极大提高效率。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/7/73/Mux_color.png"></p><p>keep-alive 的 HTTP pipelining 相当于单线程的，而 HTTP2 相当于并发。</p><p>HTTP2 的优点：</p><ul><li>对HTTP头字段进行数据压缩(即HPACK算法)；</li><li>HTTP/2 服务端推送(Server Push)；</li><li>请求管线化；</li><li>修复HTTP/1.0版本以来未修复的队头阻塞问题；</li><li>对数据传输采用多路复用，让多个请求合并在同一 TCP连接内。</li></ul><p>后三个优点其实都是<strong>多路复用</strong>带来的优点。</p><h1 id="HTTP3相关"><a href="#HTTP3相关" class="headerlink" title="HTTP3相关"></a>HTTP3相关</h1><h2 id="HTTP-3-新特性"><a href="#HTTP-3-新特性" class="headerlink" title="HTTP/3 新特性"></a>HTTP/3 新特性</h2><h3 id="1-HTTP-3简介"><a href="#1-HTTP-3简介" class="headerlink" title="1. HTTP/3简介"></a>1. HTTP/3简介</h3><p>虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，主要是底层支撑的 TCP 协议造成的。</p><p>上文提到 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。</p><p>因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。</p><p>那么可能就会有人考虑到去修改 TCP 协议，其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。</p><p>基于这个原因，<strong>Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上</strong>，HTTP/3 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。</p><p>QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个QUIC新功能。</p><h3 id="2-QUIC新功能"><a href="#2-QUIC新功能" class="headerlink" title="2. QUIC新功能"></a>2. QUIC新功能</h3><ul><li><strong>0-RTT</strong></li></ul><p>通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。那什么是 0RTT 建连呢？</p><p>这里面有两层含义:</p><ol><li>传输层 0RTT 就能建立连接。</li><li>加密层 0RTT 就能建立加密连接。</li></ol><p><img src="https://jangdelong.github.io/blog_img/images/front-end-notes-2/1.jpg"></p><p>上图左边是 HTTPS 的一次完全握手的建连过程，需要 3 个 RTT。就算是会话复用也需要至少 2 个 RTT。</p><p>而 QUIC 呢？由于建立在 UDP 的基础上，同时又实现了 0RTT 的安全握手，所以在大部分情况下，只需要 0 个 RTT 就能实现数据发送，在实现前向加密的基础上，并且 0RTT 的成功率相比 TLS 的会话记录单要高很多。</p><ul><li><strong>多路复用</strong></li></ul><p>虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题。</p><p>同HTTP2.0一样，同一条 QUIC连接上可以创建多个stream，来发送多个HTTP请求，但是，QUIC是基于UDP的，一个连接上的多个stream之间没有依赖。比如下图中stream2丢了一个UDP包，不会影响后面跟着 Stream3 和 Stream4，不存在 TCP 队头阻塞。虽然stream2的那个包需要重新传，但是stream3、stream4的包无需等待，就可以发给用户。</p><p><img src="https://jangdelong.github.io/blog_img/images/front-end-notes-2/2.jpg"></p><p>另外QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。</p><ul><li><strong>加密认证的报文</strong></li></ul><p>TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。</p><p>但是 QUIC 的 packet 可以说是武装到了牙齿。除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。</p><p>这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。</p><p><img src="https://jangdelong.github.io/blog_img/images/front-end-notes-2/3.jpg"></p><p>如上图所示，红色部分是 Stream Frame 的报文头部，有认证。绿色部分是报文内容，全部经过加密。</p><ul><li><strong>向前纠错机制</strong></li></ul><p>QUIC协议有一个非常独特的特性，称为向前纠错 (Forward Error Correction，FEC)，每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间（包括确认数据包丢失、请求重传、等待新数据包等步骤的时间消耗）。</p><p>假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HTTP/1.x 有连接无法复用、队头阻塞、协议开销大和安全因素等多个缺陷；<br>HTTP/2 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的；<br>QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。</p><h1 id="小程序优化"><a href="#小程序优化" class="headerlink" title="小程序优化"></a>小程序优化</h1><blockquote><p>以本人所项接触的项目（IM相关）实战为例</p></blockquote><ol><li>去除后端返回来的冗余字段；</li><li>状态管理（以为项目使用的是 <code>mpVue</code> 小程序开发框架） ；</li><li>图片资源优化（采用 CDN）；</li><li>图片使用 CDN 之后发现网络请求多了还是给人感觉体验不好，所以又采取了部分较小的图片直接打包进了项目 JS，由于担心小程序项目大小过大，所以才去分包；</li><li>群组人员 ID 缓存，并通过 ID 数组是否变化来加载人员信息。</li></ol><h1 id="Webpack-优化"><a href="#Webpack-优化" class="headerlink" title="Webpack 优化"></a>Webpack 优化</h1><ol><li>externals + cdn；</li><li>cache-loader；</li><li>happy-pack、thread-loader；</li><li>webpack-bundle-analyzer</li><li>Tree Shaking</li><li>CommonChunkPlugin (Webpack 4.0移除，使用 SplitChunkPlugin 替代)；</li><li>DllPlugin 和 DllReferencePlugin：DLLPlugin 就是将包含大量复用模块且不会频繁更新的库进行编译，只需要编译一次，编译完成后存在指定的文件（这里可以称为动态链接库）中。在之后的构建过程中不会再对这些模块进行编译，而是直接使用 DllReferencePlugin 来引用动态链接库的代码。</li></ol><h1 id="浏览器渲染页面的过程"><a href="#浏览器渲染页面的过程" class="headerlink" title="浏览器渲染页面的过程"></a>浏览器渲染页面的过程</h1><p>从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事情上：</p><ol><li>DNS 查询</li><li>TCP 连接</li><li>HTTP 请求即响应</li><li>服务器响应</li><li>客户端渲染</li></ol><p>浏览器对内容的渲染，这一部分（渲染树构建、布局及绘制），又可以分为下面五个步骤：</p><ol><li>处理 HTML 标记并构建 DOM 树。</li><li>处理 CSS 标记并构建 CSSOM 树。</li><li>将 DOM 与 CSSOM 合并成一个渲染树。</li><li>根据渲染树来布局，以计算每个节点的几何信息。</li><li>将各个节点绘制到屏幕上。</li></ol><h1 id="async-await-与-Generator-区别"><a href="#async-await-与-Generator-区别" class="headerlink" title="async/await 与 Generator 区别"></a>async/await 与 Generator 区别</h1><p>ES7 提出的async 函数，终于让 JavaScript 对于异步操作有了终极解决方案。No more callback hell。</p><p>async 函数是 Generator 函数的语法糖。使用 关键字 async 来表示，在函数内部使用 await 来表示异步。</p><p>想较于 Generator，Async 函数的改进在于下面四点：</p><ul><li><strong>内置执行器</strong>。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样；</li><li><strong>更好的语义</strong>。async 和 await 相较于 * 和 yield 更加语义化；</li><li><strong>更广的适用性</strong>。co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise对象。而 async 函数的 await 命令后面则可以是 Promise 或者 原始类型的值（Number，string，boolean，但这时等同于同步操作）；</li><li><strong>返回值是 Promise</strong>。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用。</li></ul><h1 id="JSONP-封装"><a href="#JSONP-封装" class="headerlink" title="JSONP 封装"></a>JSONP 封装</h1><blockquote><p>以下是之前在做跨域项目所封装的 jsonp 库</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  options = options || &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (!options.url) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;参数不合法&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 script 标签并加入到页面中, 如果没传callback默认生成一个</span></span><br><span class="line">  <span class="keyword">let</span> callbackName = options.callback || options.data[<span class="string">&#x27;callback&#x27;</span>] ||　(<span class="string">&#x27;jsonp_&#x27;</span> + <span class="built_in">Math</span>.random()).replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> oHead = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">  options.data[<span class="string">&#x27;callback&#x27;</span>] = callbackName</span><br><span class="line">  <span class="keyword">let</span> params = formatParams(options.data)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> oScript = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">  oHead.appendChild(oScript);</span><br><span class="line">  <span class="comment">// 创建jsonp回调函数</span></span><br><span class="line">  <span class="built_in">window</span>[callbackName] = <span class="function"><span class="keyword">function</span> (<span class="params">json</span>) </span>&#123;</span><br><span class="line">    oHead.removeChild(oScript)</span><br><span class="line">    <span class="built_in">clearTimeout</span>(oScript.timer)</span><br><span class="line">    <span class="built_in">window</span>[callbackName] = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (json) &#123;</span><br><span class="line">      options.success &amp;&amp; options.success(json)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      options.fail &amp;&amp; options.fail(&#123; <span class="attr">code</span>: <span class="string">&#x27;FS_UNKNOW&#x27;</span>, <span class="attr">summary</span>: <span class="string">&#x27;请求错误&#x27;</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送请求</span></span><br><span class="line">  oScript.src = options.url + (options.url.indexOf(<span class="string">&#x27;?&#x27;</span>) &gt; -<span class="number">1</span> ? <span class="string">&#x27;&amp;&#x27;</span> : <span class="string">&#x27;?&#x27;</span>) + params</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 超时处理</span></span><br><span class="line">  <span class="keyword">if</span> (options.time) &#123;</span><br><span class="line">    oScript.timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">window</span>[callbackName] = <span class="literal">null</span></span><br><span class="line">      oHead.removeChild(oScript)</span><br><span class="line">      options.fail &amp;&amp; options.fail(&#123; <span class="attr">code</span>: <span class="string">&#x27;S_FAIL&#x27;</span>, <span class="attr">summary</span>: <span class="string">&#x27;请求超时&#x27;</span> &#125;)</span><br><span class="line">    &#125;, options.time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="平民版深度拷贝"><a href="#平民版深度拷贝" class="headerlink" title="平民版深度拷贝"></a>平民版深度拷贝</h1><blockquote><p>比乞丐版 <code>JSON.parse(JSON.stringify(obj))</code> 好点的深度拷贝</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> deepClone = <span class="function"><span class="params">target</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> newTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> target[i] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        newTarget[i] = deepClone(target[i])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newTarget[i] = target[i]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTarget</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="instanceof-实现"><a href="#instanceof-实现" class="headerlink" title="instanceof 实现"></a>instanceof 实现</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new_instance_of</span>(<span class="params">leftVaule, rightVaule</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> rightProto = rightVaule.prototype; <span class="comment">// 取右表达式的 prototype 值</span></span><br><span class="line">    leftVaule = leftVaule.__proto__; <span class="comment">// 取左表达式的__proto__值</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftVaule === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftVaule === rightProto) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        leftVaule = leftVaule.__proto__ </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="new-封装"><a href="#new-封装" class="headerlink" title="new 封装"></a>new 封装</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">Con, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(Con.prototype)</span><br><span class="line">  <span class="keyword">let</span> result = Con.apply(obj, args)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="手写-Promise-（乞丐版）"><a href="#手写-Promise-（乞丐版）" class="headerlink" title="手写 Promise （乞丐版）"></a>手写 Promise （乞丐版）</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">  <span class="built_in">this</span>.reason = <span class="literal">undefined</span></span><br><span class="line">  <span class="built_in">this</span>.status = <span class="string">&#x27;pending&#x27;</span> <span class="comment">// 状态 pending、resolved、rejected，默认为 pending</span></span><br><span class="line">  <span class="built_in">this</span>.resolvedCallbacks = []</span><br><span class="line">  <span class="built_in">this</span>.rejectedCallbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.pending === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.value = value</span><br><span class="line">      <span class="built_in">this</span>.status = <span class="string">&#x27;resolved&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.resolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.pending === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.reason = reason</span><br><span class="line">      <span class="built_in">this</span>.status = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.rejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  executor(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;resolved&#x27;</span>) &#123;</span><br><span class="line">    fn(<span class="built_in">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.resolvedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn(<span class="built_in">this</span>.value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">    fn(<span class="built_in">this</span>.reason)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.rejectedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn(<span class="built_in">this</span>.reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h1><ul><li>flex-grow属性</li></ul><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><ul><li>flex-shrink属性</li></ul><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br>负值对该属性无效。</p><ul><li>flex-basis属性</li></ul><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在写这篇前端散记之前有写过另外一篇散记，可点击 &lt;a href=&quot;https://jelon.info/posts/front-end-notes/&quot;&gt;前端散记&lt;/a&gt; 访问。所谓散记，东西都比较零散，更谈不上什么深入，但是至少可以让读者知道一些概</summary>
      
    
    
    
    <category term="Web技术" scheme="https://jangdelong.github.io/blog/categories/Web%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="前端" scheme="https://jangdelong.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】141. 环形链表</title>
    <link href="https://jangdelong.github.io/blog/posts/leetcode-141/"/>
    <id>https://jangdelong.github.io/blog/posts/leetcode-141/</id>
    <published>2020-05-07T00:00:00.000Z</published>
    <updated>2020-05-07T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p><p><strong>示例 1：</strong></p><p><img src="https://jangdelong.github.io/blog_img/images/leetcode-141/circularlinkedlist.png" alt="https://jangdelong.github.io/blog_img/images/leetcode-141/circularlinkedlist.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">head</span> = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], <span class="attr">pos</span> = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://jangdelong.github.io/blog_img/images/leetcode-141/circularlinkedlist_test2.png" alt="https://jangdelong.github.io/blog_img/images/leetcode-141/circularlinkedlist_test2.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">head</span> = [<span class="number">1</span>,<span class="number">2</span>], <span class="attr">pos</span> = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://jangdelong.github.io/blog_img/images/leetcode-141/circularlinkedlist_test3.png" alt="https://jangdelong.github.io/blog_img/images/leetcode-141/circularlinkedlist_test2.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">head</span> = [<span class="number">1</span>], <span class="attr">pos</span> = -<span class="number">1</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p> </p><p><strong>进阶：</strong></p><p>你能用 O(1)（即，常量）内存解决此问题吗？</p><h5 id="个人解答"><a href="#个人解答" class="headerlink" title="个人解答"></a>个人解答</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 快慢指针</span></span><br><span class="line">  <span class="keyword">let</span> slow = head;</span><br><span class="line">  <span class="keyword">let</span> fast = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (slow &amp;&amp; fast &amp;&amp; fast.next) &#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    <span class="keyword">if</span> (slow === fast) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>通过使用具有 不同速度 的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)。慢指针每次移动一步，而快指针每次移动两步。</p><p>如果列表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 false。</p><p>现在考虑一个环形链表，把慢指针和快指针想象成两个在环形赛道上跑步的运动员（分别称之为慢跑者与快跑者）。而快跑者最终一定会追上慢跑者。这是为什么呢？考虑下面这种情况（记作情况 A）- 假如快跑者只落后慢跑者一步，在下一次迭代中，它们就会分别跑了一步或两步并相遇。</p><ul><li>时间复杂度：O(n)；</li><li>空间复杂度：O(1)。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个链表，判断链表中是否有环。&lt;/p&gt;
&lt;p&gt;为了表示给定链表中的环，我们使用整数 &lt;code&gt;pos&lt;/code&gt; 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 &lt;code&gt;pos&lt;/code&gt; 是 &lt;code&gt;-1&lt;/code&gt;，则在该链表中没有环。&lt;</summary>
      
    
    
    
    <category term="算法练习" scheme="https://jangdelong.github.io/blog/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://jangdelong.github.io/blog/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://jangdelong.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】面试题 02.03. 删除中间节点</title>
    <link href="https://jangdelong.github.io/blog/posts/leetcode-case-02-03/"/>
    <id>https://jangdelong.github.io/blog/posts/leetcode-case-02-03/</id>
    <published>2020-05-06T00:00:00.000Z</published>
    <updated>2020-05-06T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。</p><p> </p><p><strong>示例：</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：单向链表<span class="function"><span class="title">a</span>-&gt;</span><span class="function"><span class="title">b</span>-&gt;</span><span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">d</span>-&gt;</span><span class="function"><span class="title">e</span>-&gt;</span>f中的节点c</span><br><span class="line">结果：不返回任何数据，但该链表变为<span class="function"><span class="title">a</span>-&gt;</span><span class="function"><span class="title">b</span>-&gt;</span><span class="function"><span class="title">d</span>-&gt;</span><span class="function"><span class="title">e</span>-&gt;</span>f</span><br></pre></td></tr></table></figure><h5 id="个人解答"><a href="#个人解答" class="headerlink" title="个人解答"></a>个人解答</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">node</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> current = node;</span><br><span class="line">  node.val = current.next.val;</span><br><span class="line">  node.next = current.next.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>删除当前节点只需要把当前节点指向下个节点值即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight xl&quot;&gt;&lt;table&gt;&lt;tr&gt;</summary>
      
    
    
    
    <category term="算法练习" scheme="https://jangdelong.github.io/blog/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://jangdelong.github.io/blog/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://jangdelong.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】22. 括号生成</title>
    <link href="https://jangdelong.github.io/blog/posts/leetcode-22/"/>
    <id>https://jangdelong.github.io/blog/posts/leetcode-22/</id>
    <published>2020-04-09T00:00:00.000Z</published>
    <updated>2020-04-09T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p> </p><p><strong>示例：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">3</span></span><br><span class="line">输出：[</span><br><span class="line">       <span class="string">&quot;((()))&quot;</span>,</span><br><span class="line">       <span class="string">&quot;(()())&quot;</span>,</span><br><span class="line">       <span class="string">&quot;(())()&quot;</span>,</span><br><span class="line">       <span class="string">&quot;()(())&quot;</span>,</span><br><span class="line">       <span class="string">&quot;()()()&quot;</span></span><br><span class="line">     ]</span><br></pre></td></tr></table></figure><h5 id="参考解答"><a href="#参考解答" class="headerlink" title="参考解答"></a>参考解答</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  dfs(<span class="string">&#x27;&#x27;</span>, n, n, res)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深度遍历（回溯）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span> (<span class="params">curStr, left, right, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当左括号、右括号剩余数均为0时终止递归</span></span><br><span class="line">  <span class="keyword">if</span> (left === <span class="number">0</span> &amp;&amp; right === <span class="number">0</span>) &#123;</span><br><span class="line">    res.push(curStr)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当左括号剩余数大于右括号剩余数</span></span><br><span class="line">  <span class="comment">// 即，已使用的左括号数少于已使用的右括号数</span></span><br><span class="line">  <span class="comment">// 终止递归</span></span><br><span class="line">  <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    dfs(curStr + <span class="string">&#x27;(&#x27;</span>, left - <span class="number">1</span>, right, res)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    dfs(curStr + <span class="string">&#x27;)&#x27;</span>, left, right - <span class="number">1</span>, res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>深度优先（回溯）：</p><ol><li><p>当前左右括号都有大于 0 个可以使用的时候，才产生分支；</p></li><li><p>产生左分支的时候，只看当前是否还有左括号可以使用；</p></li><li><p>产生右分支的时候，还受到左分支的限制，右边剩余可以使用的括号数量一定得在严格大于左边剩余的数量的时候，才可以产生分支；</p></li><li><p>在左边和右边剩余的括号数都等于 0 的时候结算。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight excel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    <category term="算法练习" scheme="https://jangdelong.github.io/blog/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="LeetCode" scheme="https://jangdelong.github.io/blog/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://jangdelong.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
